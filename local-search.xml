<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Unity 学习 --- (1)</title>
    <link href="/2022/07/26/Unity-%E5%AD%A6%E4%B9%A0-1/"/>
    <url>/2022/07/26/Unity-%E5%AD%A6%E4%B9%A0-1/</url>
    
    <content type="html"><![CDATA[<p><img src="/../images/UnityShow.png" alt="Unity 界面"></p><p>Unity 本身上是基于组件的方式运行的，如果我们需要为组件添加没有的功能的时候，我们就需要借助于 C# 脚本的方式。如下是相关的函数原型介绍</p><h1 id="Unity-组件函数的功能"><a href="#Unity-组件函数的功能" class="headerlink" title="Unity 组件函数的功能"></a>Unity 组件函数的功能</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Move</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 初始化的函数</span><br>        Debug.Log(<span class="hljs-string">&quot;Step 1:awake&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 激活的时候调用一下</span><br>        Debug.Log(<span class="hljs-string">&quot;Step 2:OnEnable&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 只调用一次 </span><br>        Debug.Log(<span class="hljs-string">&quot;Step 3:Start&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 每一帧调用一次</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 每一帧调用一次</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 每隔固定的间隔进行运行</span><br>        <span class="hljs-comment">// Debug.Log(&quot;fixedUpdate&quot;);</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 非激活的时候进行调用</span><br>        Debug.Log(<span class="hljs-string">&quot;Step 6:nDisable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 销毁的时候调用</span><br>        Debug.Log(<span class="hljs-string">&quot;Step 7:OnDestroy&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>Tips：需要注意的是，对于不同的脚本而言，其也是按照如上的优先级进行执行的。也就是说如果存在多个脚本 test1 和 test2 ，test2 的 awake 函数也是早于 test1 的 Start 函数的。</strong></p><h1 id="Vector-类："><a href="#Vector-类：" class="headerlink" title="Vector 类："></a>Vector 类：</h1><h2 id="常见的函数类型："><a href="#常见的函数类型：" class="headerlink" title="常见的函数类型："></a>常见的函数类型：</h2><p>对于向量的类型而言，其对应的常见的操作如下所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Vector3 v = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vector3(1, 1, 1f)</span>;<br><span class="hljs-comment">// 初始化为全0的向量</span><br>v = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vector3</span>.</span></span>zero;<br><span class="hljs-comment">//// 初始化为全1的向量</span><br>v = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vector3</span>.</span></span>one;<br><span class="hljs-comment">// 坐标为 (1,0,0)</span><br>Vector3 v1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vector3</span>.</span></span>right;<br>Vector3 v2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vector3</span>.</span></span>forward;<br><br><span class="hljs-comment">// 快速计算角度</span><br>Debug.<span class="hljs-constructor">Log(Vector3.Angle(<span class="hljs-params">v1</span>, <span class="hljs-params">v2</span>)</span>);<br><br><span class="hljs-comment">// 快速计算距离</span><br>Debug.<span class="hljs-constructor">Log(Vector3.Distance(<span class="hljs-params">v1</span>, <span class="hljs-params">v2</span>)</span>);<br><br><span class="hljs-comment">// 点乘</span><br>Debug.<span class="hljs-constructor">Log(Vector3.Dot(<span class="hljs-params">v1</span>, <span class="hljs-params">v2</span>)</span>);<br><br><span class="hljs-comment">// 叉乘</span><br>Debug.<span class="hljs-constructor">Log(Vector3.Cross(<span class="hljs-params">v1</span>, <span class="hljs-params">v2</span>)</span>);<br><br><span class="hljs-comment">// 插值</span><br>Debug.<span class="hljs-constructor">Log(Vector3.Lerp(Vector3.<span class="hljs-params">zero</span>, Vector3.<span class="hljs-params">one</span>, 0.8f)</span>);<br><br><span class="hljs-comment">// 求向量的模长</span><br>Debug.<span class="hljs-constructor">Log(<span class="hljs-params">v</span>.<span class="hljs-params">magnitude</span>)</span>;<br><br><span class="hljs-comment">// 规范化向量</span><br>Debug.<span class="hljs-constructor">Log(<span class="hljs-params">v</span>.<span class="hljs-params">normalized</span>)</span>;<br><br></code></pre></td></tr></table></figure><h2 id="角度的表示"><a href="#角度的表示" class="headerlink" title="角度的表示"></a>角度的表示</h2><p>对于unity而言，对于一个物体而言，其存在两种角度表示的方式：</p><pre><code class="hljs">· 欧拉角 --&gt;  角度制的表示形式· 四元组的方式 --&gt; 具有较好的特性</code></pre><p>其常见的函数主要有：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Vector3 rotate = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vector3(0, 30, 0)</span>; <span class="hljs-comment">// --&gt; 对应的欧拉角</span><br><br><span class="hljs-comment">// 四元组对应的角度</span><br>Quaternion quater = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Quaternion</span>.</span></span>identity;<br><br><span class="hljs-comment">// 欧拉角对应的四元组</span><br>quater = Quaternion.<span class="hljs-constructor">Euler(<span class="hljs-params">rotate</span>)</span>;<br><br><span class="hljs-comment">// 四元组转换为欧拉角</span><br>rotate = quater.eulerAngles;<br><br><span class="hljs-comment">// 看向一个物体</span><br>quater = Quaternion.<span class="hljs-constructor">LookRotation(<span class="hljs-params">new</span> Vector3(0, 0, 0)</span>);<br></code></pre></td></tr></table></figure><h1 id="Time-类"><a href="#Time-类" class="headerlink" title="Time 类"></a>Time 类</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// 游戏开始到现在所花的时间<br><span class="hljs-keyword">Debug</span>.Log(<span class="hljs-type">Time</span>.time);<br><br>// 时间缩放值 <span class="hljs-comment">--&gt; 涉及到快进和后退</span><br><span class="hljs-keyword">Debug</span>.Log(<span class="hljs-type">Time</span>.timeScale);<br><br>// 固定时间间隔<br><span class="hljs-keyword">Debug</span>.Log(<span class="hljs-type">Time</span>.fixedDeltaTime);<br><br>// 上一帧到这一帧所用的时间<br><span class="hljs-keyword">Debug</span>.Log(<span class="hljs-type">Time</span>.deltaTime);<br><br>// 游戏的运行时间 本质上就是一个自定义的计时器<br>timer += TimeDeltaTime;<br></code></pre></td></tr></table></figure><h1 id="Application-类"><a href="#Application-类" class="headerlink" title="Application 类"></a>Application 类</h1><p>主要是为了获取对应的路径信息等操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 游戏数据文件夹路径（只读，加密压缩）</span><br>Debug.<span class="hljs-constructor">Log(Application.<span class="hljs-params">dataPath</span>+<span class="hljs-string">&quot;/新建文本文档.txt&quot;</span>)</span>;<br><br><span class="hljs-comment">// 持续化文件夹路径</span><br>Debug.<span class="hljs-constructor">Log(Application.<span class="hljs-params">persisterDataPath</span>)</span>;<br><br><span class="hljs-comment">// streamingAssets 文件夹路径（只读，配置文件，不会进行压缩处理的）</span><br>Debug.<span class="hljs-constructor">Log(Application.<span class="hljs-params">streamingAssets</span>)</span>;<br><br><span class="hljs-comment">// 临时文件夹</span><br>Debug.<span class="hljs-constructor">Log(Application.<span class="hljs-params">temporaryCachePath</span>)</span>;<br><br><span class="hljs-comment">// 控制是否在后台运行</span><br>Debug.<span class="hljs-constructor">Log(Application.<span class="hljs-params">runInBackground</span>)</span>;<br><br><span class="hljs-comment">// 打开一个url</span><br>Application.<span class="hljs-constructor">OpenURL(<span class="hljs-string">&quot;https://i-spoon.github.io&quot;</span>)</span>;<br><br><span class="hljs-comment">// 退出游戏</span><br>Application.<span class="hljs-constructor">Quit()</span>;<br></code></pre></td></tr></table></figure><h1 id="调试的方法："><a href="#调试的方法：" class="headerlink" title="调试的方法："></a>调试的方法：</h1><p>对应给定的脚本内容，为了检验其是否具有我们需要的运行效果，我们通常结合调试工具去进行调试，其常用的函数形式如下所示：</p><p>我们可以通过控制台文本输出，其对应的函数主要包括：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><br><span class="hljs-built_in">Debug</span><span class="hljs-operator">.</span><span class="hljs-built_in">Log</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;正常的输出方式&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><br><span class="hljs-built_in">Debug</span><span class="hljs-operator">.</span><span class="hljs-variable">LogWarning</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;输出警告&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><br><span class="hljs-built_in">Debug</span><span class="hljs-operator">.</span><span class="hljs-variable">LogError</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;输出错误&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><br></code></pre></td></tr></table></figure><p>同样的，我们也可以绘制一些线来进行表示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 绘制一条线 起点 终点 颜色</span><br>Debug.<span class="hljs-constructor">DrawLine(Vector3.<span class="hljs-params">zero</span>,Vector3.<span class="hljs-params">one</span>,Color.<span class="hljs-params">blue</span>)</span>;<br><br><span class="hljs-comment">// 绘制一条射线：起点 终点 射线</span><br>Debug.<span class="hljs-constructor">DrawRay(Vector3.<span class="hljs-params">zero</span>,<span class="hljs-params">vector</span>.<span class="hljs-params">up</span>,Color.<span class="hljs-params">red</span>)</span>;<br></code></pre></td></tr></table></figure><h1 id="物体属性的动态修改"><a href="#物体属性的动态修改" class="headerlink" title="物体属性的动态修改"></a>物体属性的动态修改</h1><p>考虑到物体的属性需要进行更改的，我们可以结合脚本的方式对物体的属性进行修改。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 物体的名称</span><br>Debug.<span class="hljs-constructor">Log(<span class="hljs-params">gameObject</span>.<span class="hljs-params">name</span>)</span>;<br><br><span class="hljs-comment">// 物体的标签</span><br>Debug.<span class="hljs-constructor">Log(<span class="hljs-params">gameObject</span>.<span class="hljs-params">tag</span>)</span>;<br><br><span class="hljs-comment">// 物体的层</span><br>Debug.<span class="hljs-constructor">Log(<span class="hljs-params">gameObject</span>.<span class="hljs-params">layyer</span>)</span>;<br><br></code></pre></td></tr></table></figure><p>同时，对于一个物体而言，我们还需要考虑其是否处于激活状态。考虑到仅仅有一个物体的话，它对应的状态一定是激活状态的，所以，我们可以通过父物体和子物体的关系去进行表示。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// 物体的名称<br><span class="hljs-keyword">Debug</span>.Log(<span class="hljs-keyword">Cube</span>.name);<br><br>// 当前真正的激活状态  <span class="hljs-comment">--&gt; 受限于父物体的激活状态</span><br><span class="hljs-keyword">Debug</span>.Log(<span class="hljs-keyword">Cube</span>.activeInHierarchy);<br><br>// 当前自身的激活状态 <br><span class="hljs-keyword">Debug</span>.Log(<span class="hljs-keyword">Cube</span>.activeSelf);<br></code></pre></td></tr></table></figure><p>同时，考虑到在游戏运行过程中，其可能需要我们动态相应的组件内容，也可以为其对应的子对象添加相应的内容。对应的函数原型如下所示：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获取transform 组件  默认挂载的组件<br>Debug.Log(transform.postion);<br><br><span class="hljs-regexp">//</span> 获取其他组件<br>BoxColider bc=GetComponent&lt;BoxColider&gt;();<br><br><span class="hljs-regexp">//</span> 获取子物体身上的组件<br>GetComponentChildren&lt;CapsuleColider&gt;();<br><br><span class="hljs-regexp">//</span> 获取父物体身上的组件<br>GetComponentParent&lt;CapsuleColider&gt;();<br><br><span class="hljs-regexp">//</span> 添加一个组件<br>game.AddComponent&lt;AudioSource&gt;();<br><br><span class="hljs-regexp">//</span> 通过游戏物体的名称来获取游戏物体<br>GameObject test=GameObject.Find(<span class="hljs-string">&quot;Test&quot;</span>);<br><br><span class="hljs-regexp">//</span> 通过游戏物体的标签来进行获取<br>GameObject test=GameObject.FindWithTag(<span class="hljs-string">&quot;Enemy&quot;</span>);<br></code></pre></td></tr></table></figure><p>同时，我们也需要在代码中执行相应的操作，使得其可以实例化对应的游戏物体。对应的代码执行过程如下所示：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 利用预设体设计<br>Instantiate(<span class="hljs-regexp">/* 预设体 */</span>);<br><br><span class="hljs-regexp">//</span> 作为当前的子物体<br>GameObject go=Instantiate(<span class="hljs-regexp">/* 预设体 */</span>,transform);<br><br><span class="hljs-regexp">//</span> 销毁物体<br>Destroy(go);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity 入门</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity 系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 创建新的文章</title>
    <link href="/2022/07/24/Hexo-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <url>/2022/07/24/Hexo-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>本网站主要采用的 Hexo 的方式搭建博客界面，为了更好地方便的更新操作，这里主要讲述一下 Hexo 的配置过程，以及文章发布的过程。</p><span id="more"></span><p><a href="https://hexo.io/zh-cn/">Hexo</a>是一种快速、简洁且高效的博客框架，其具有较好的拓展性以及简洁性，支持Markdown语法。接下来，我们将从安装、更新以及部署的角度进行进一步的阐述。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装 Hexo 需要提前具备 <a href="https://nodejs.org/en/">Node.js</a> 以及 <a href="https://git-scm.com/">Git</a> 工具。在安装完成工具之后，我们就可以进行Hexo的安装。</p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>所有必备的应用程序安装完成后，即可使用npm完成安装Hexo。我们在控制台键入如下命令：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g Hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>等待安装完成之后，即可执行如下命令，Hexo 将会在指定的文件夹中新建需要的文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;文件夹的名称&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;文件夹的名称&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><p>此时，对应的新建的文件夹的目录结构如下所示：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></td></tr></table></figure><p>其中，themes中可以放置我们想要采用的主题。我们以fluid主题为例：</p><h2 id="主题的更新"><a href="#主题的更新" class="headerlink" title="主题的更新"></a>主题的更新</h2><p>我们可以下载fluid的最新<a href="https://github.com/fluid-dev/Hexo-theme-fluid/releases">release</a>版本，并将解压出的文件夹重命名为fluid。</p><h3 id="指定主题"><a href="#指定主题" class="headerlink" title="指定主题"></a>指定主题</h3><p>在下载完成之后，我们可以修改对应文件夹目录下的 <code>_config.yml</code> ,使之对应的主题为fluid。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># 需要注意的是 “:” 与后续的文本需要以空格隔开</span><br><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题</span><br><span class="hljs-symbol">language:</span><span class="hljs-built_in">zh</span>-CN <span class="hljs-meta"># 指定语言</span><br></code></pre></td></tr></table></figure><p>此时，我们就可以将主题更换成我们想要更换的形式。</p><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>配置好相应的 Hexo 主体之后，我们就可以更新我们的博客信息。首先，我们需要新建对应的页面,我们需要现在对应的博客目录下，键入如下命令：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;博客的标题&quot;</span><br></code></pre></td></tr></table></figure><p>等待执行完毕之后，我们就可以在<code>source/_post/ </code> 目录下找到我们新生成的页面信息。此时，我们就可以按照 Markdown 的语法标准书写相关的内容信息。<br>编写完成之后，我们可以在控制台中键入如下命令：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">$ hexo clean ## 清空缓存<br>$ hexo g  ## 静态页面的部署<br>$ hexo d  ## 推送到服务器上<br></code></pre></td></tr></table></figure><p>此时,我们就可以通过如下命令，实现在本机上的查看操作：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>此时，我们就可以在<a href="http://localhost:5000/">5000端口</a>查看。为了方便后续的查看操作，我们可以将对应的网站部署在github上，方便后续的查看。</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h2><p>为了方便部署，我们需要结合 git 工具，实现对应的查看操作。首先，我们需要绑定注册邮箱以及注册用户名，我们需要打开 git bash，并在其中键入如下命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;此处填写你注册时的用户名&quot;</span><br>$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;此处填写你注册时的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>此时，我们即将 git 工具与我们的账号进行绑定。</p><h2 id="配置-github"><a href="#配置-github" class="headerlink" title="配置 github"></a>配置 github</h2><h3 id="创建："><a href="#创建：" class="headerlink" title="创建："></a>创建：</h3><p>我们需要新建一个名为你的用户名的github.io的仓库。对应的命名规则如下所示：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">UserName.github.io  ## 其中UserName为用户名<br></code></pre></td></tr></table></figure><p>需要注意的是：</p><pre><code class="hljs">· 注册的邮箱一定要验证· 仓库名字必须是：UserName.github.io</code></pre><p>创建完毕之后，我们还需要配置相应的 SSH 免密登录。</p><h2 id="配置-SSH-免密登录"><a href="#配置-SSH-免密登录" class="headerlink" title="配置 SSH 免密登录"></a>配置 SSH 免密登录</h2><p>为了更加方便提交代码内容，同时为了避免使用直接使用用户名和密码，我们通过 ssh key 的方式来解决本地和服务器的链接问题。也就是，通过这种方式给予本机访问 github 仓库的权限。</p><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>1.创建一个git bash 秘钥。我们需要在 git bash 中键入如下命令，生成对应的秘钥信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ <span class="hljs-attribute">ssh</span>=keygen =t rsa -C <span class="hljs-string">&quot;邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>然后enter三连，（如果想要键入自己的密码信息，我们可以在键入一个enter之后键入自己的密码内容）。此时，会在对应位置生成</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">.<br>├── id_rsa ## 私钥内容<br>├── id_rsa.pub ## 公钥内容<br><br></code></pre></td></tr></table></figure><p>此时，我们需要将公钥内容添加到github中</p><p>2.在github中添加SSH key。我们可以以记事本的方式打开对应的id_rsa.pub内容，并将其中的内容粘贴到对应的key中，其中title可以随意填写。配置完成之后，我们可以通过如下命令检验我们的SSH key是否连接成功：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh -T git<span class="hljs-variable">@github</span>.com<br><br></code></pre></td></tr></table></figure><p>3._config.yml的配置。在添加完成之后，我们需要在对应的配置文件中添加如下的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attr">repo:</span> <br>    <span class="hljs-attr">github:</span> <span class="hljs-string">git@github.com:UserName/UserName.github.io.git,master</span> <span class="hljs-comment">## 其中UserName 为对应的用户名称</span><br></code></pre></td></tr></table></figure><p>4.添加完成之后,我们即可通过如下命令进行查看，为了避免上次的缓存信息对本次的查询带来干扰，对应的命令如下所示：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br><span class="hljs-variable">$ </span>hexo g<br><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><p>键入完成之后，我们就可以在 <a href="http://username.github.io/">http://UserName.github.io</a> 中进行查看。其中，UserName为用户的id信息。</p><p>如上即为Hexo的配置过程。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo 配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo 入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
